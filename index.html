<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jumper</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        canvas {
            border: 3px solid #0f3460;
            box-shadow: 0 0 20px rgba(22, 33, 62, 0.8);
            border-radius: 10px;
            cursor: pointer;
            display: block;
            touch-action: none; /* Previne ações do browser como zoom */
        }
        #instructions {
            margin-top: 10px;
            font-size: 12px;
            color: #e94560;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="instructions">Use ⬅️ e ➡️ para mover. Pegue a chave e chegue à porta!</div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Estado do jogo
    let gameOver = false;
    let gameWon = false;
    let level = 1;
    let menuOpen = false;

    // Propriedades do jogador
    const jumper = {
        x: 100, y: canvas.height / 2, radius: 20,
        dx: 0, dy: 0, color: '#2c3e50', lives: 3, // Cor alterada para o pinguim
        onGround: false, isSquashing: false, squashFactor: 1,
        isCharging: false, chargePower: 0,
    };

    // Propriedades do ambiente
    const gravity = 0.3; 
    const bounceFactor = 0.8;
    const horizontalSpeed = 5;
    let sunY = 150;
    
    // Propriedades do Pulo
    const minJumpForce = -10;
    const maxChargePower = 25;

    const keys = { right: false, left: false, space: false };

    // Estrutura dos níveis
    const spikes = [];
    const platforms = [];
    const seagulls = [];
    const particles = []; // Array para as partículas
    let goal = {};
    const spikeWidth = 40;
    const spikeHeight = 40;
    let levelState = {
        hasKey: false,
        lifeCollected: false,
        keyPos: { x: 0, y: 0 },
        lifePos: { x: 0, y: 0 }
    };
    const clouds = [];

    const levels = [
        { // Nível 1
            startPos: { x: 100, y: 500 },
            goal: { x: 700, y: 100, width: 40, height: 80 },
            key: { x: 400, y: 450 },
            life: { x: 500, y: 220 },
            platforms: [
                { x: 0, y: 580, width: 250, height: 20, speedY: 0, speedX: 0 },
                { x: 350, y: 500, width: 200, height: 20, speedY: -0.4, speedX: 0, bounds: { top: 400, bottom: 550 } },
                { x: 150, y: 350, width: 150, height: 20, speedY: 0, speedX: 0 },
                { x: 450, y: 250, width: 150, height: 20, speedY: 0, speedX: 0 },
                { x: 650, y: 180, width: 100, height: 20, speedY: 0, speedX: 0 },
            ],
            spikes: [ { x: 400, y: 0, from: 'ceiling', dir: 'down' }, { x: 440, y: 0, from: 'ceiling', dir: 'down' } ]
        },
        // ... (restante dos níveis omitido para abreviar)
    ];

    const touchControls = {
        left: { x: 40, y: 470, width: 100, height: 100 },
        right: { x: 160, y: 470, width: 100, height: 100 },
        jump: { x: 660, y: 470, width: 100, height: 100 }
    };
    let touchMap = {}; // Mapeia o identificador de toque para o controlo ('left', 'right', 'jump')

    function loadLevel(levelNum) {
        if (levelNum > levels.length) {
            gameWon = true;
            return;
        }
        const levelData = levels[levelNum - 1];
        spikes.length = 0;
        platforms.length = 0;
        seagulls.length = 0;
        
        levelData.spikes.forEach(s => spikes.push({ ...s, width: spikeWidth, height: spikeHeight }));
        levelData.platforms.forEach(p => platforms.push({ ...p }));
        if (levelData.seagulls) {
            levelData.seagulls.forEach(s => seagulls.push({ ...s, width: 50, height: 20 }));
        }
        goal = levelData.goal;

        levelState.hasKey = false;
        levelState.lifeCollected = false;
        levelState.keyPos = { ...levelData.key };
        levelState.lifePos = { ...levelData.life };
        
        jumper.x = levelData.startPos.x;
        jumper.y = levelData.startPos.y;
        jumper.dy = 1;
    }

    // --- FUNÇÕES DE DESENHO ---
    
    function drawRoundRect(ctx, x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
        ctx.fill();
    }
    
    function initClouds() {
        if (clouds.length > 0) return;
        for (let i = 0; i < 10; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: 50 + Math.random() * 150,
                radius: 20 + Math.random() * 20,
                speed: 0.1 + Math.random() * 0.2
            });
        }
    }

    function drawBackground() {
        const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        skyGradient.addColorStop(0, '#0c1445');
        skyGradient.addColorStop(0.6, '#3b4b95');
        skyGradient.addColorStop(1, '#7f8eda');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.arc(canvas.width / 2, sunY, 50, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(0, 350);
        ctx.lineTo(150, 250);
        ctx.lineTo(300, 320);
        ctx.lineTo(500, 200);
        ctx.lineTo(650, 300);
        ctx.lineTo(800, 280);
        ctx.lineTo(800, 600);
        ctx.lineTo(0, 600);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        clouds.forEach(cloud => {
            ctx.beginPath();
            ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
            ctx.arc(cloud.x + 25, cloud.y + 10, cloud.radius * 0.8, 0, Math.PI * 2);
            ctx.arc(cloud.x - 20, cloud.y + 15, cloud.radius * 0.9, 0, Math.PI * 2);
            ctx.fill();
        });


        ctx.fillStyle = '#0a0a23';
        ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
        ctx.fillStyle = '#14143a';
        ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
    }
    
    function drawPlatforms() {
        platforms.forEach(p => {
            const cornerRadius = 10;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            drawRoundRect(ctx, p.x + 3, p.y + 3, p.width, p.height, cornerRadius);
            ctx.fillStyle = '#1687a7';
            drawRoundRect(ctx, p.x, p.y, p.width, p.height, cornerRadius);
        });
    }

    function drawJumper() {
        let displayRadiusX = jumper.radius * (2 - jumper.squashFactor);
        let displayRadiusY = jumper.radius * (jumper.squashFactor);

        const shadowOffset = 3;

        // --- Pés ---
        const footRadiusX = displayRadiusX * 0.4;
        const footRadiusY = 6;
        const footOffsetY = displayRadiusY - footRadiusY / 2;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(jumper.x - displayRadiusX * 0.5 + shadowOffset, jumper.y + footOffsetY + shadowOffset, footRadiusX, footRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(jumper.x + displayRadiusX * 0.5 + shadowOffset, jumper.y + footOffsetY + shadowOffset, footRadiusX, footRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFA500'; // Laranja
        ctx.beginPath();
        ctx.ellipse(jumper.x - displayRadiusX * 0.5, jumper.y + footOffsetY, footRadiusX, footRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(jumper.x + displayRadiusX * 0.5, jumper.y + footOffsetY, footRadiusX, footRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();


        // --- Corpo ---
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.ellipse(jumper.x + shadowOffset, jumper.y + shadowOffset, displayRadiusX, displayRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = jumper.color; // Preto
        ctx.ellipse(jumper.x, jumper.y, displayRadiusX, displayRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();

        // --- Barriga ---
        ctx.beginPath();
        ctx.fillStyle = 'white';
        ctx.ellipse(jumper.x, jumper.y + displayRadiusY * 0.1, displayRadiusX * 0.7, displayRadiusY * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();

        // --- Asas ---
        const wingRadiusX = displayRadiusX * 0.2;
        const wingRadiusY = displayRadiusY * 0.6;
        let wingAngle = 0.5; // Angulo para baixo
        if (!jumper.onGround) {
            wingAngle = -0.5; // Angulo para cima ao pular
        }
        ctx.save();
        ctx.translate(jumper.x - displayRadiusX * 0.8, jumper.y);
        ctx.rotate(-wingAngle);
        ctx.beginPath();
        ctx.fillStyle = jumper.color;
        ctx.ellipse(0, 0, wingRadiusX, wingRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.translate(jumper.x + displayRadiusX * 0.8, jumper.y);
        ctx.rotate(wingAngle);
        ctx.beginPath();
        ctx.fillStyle = jumper.color;
        ctx.ellipse(0, 0, wingRadiusX, wingRadiusY, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();


        // --- Rosto ---
        const eyeOffsetY = -displayRadiusY * 0.35;
        if (jumper.isCharging) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(jumper.x - 10, jumper.y + eyeOffsetY);
            ctx.lineTo(jumper.x - 4, jumper.y + eyeOffsetY - 1);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(jumper.x + 4, jumper.y + eyeOffsetY - 1);
            ctx.lineTo(jumper.x + 10, jumper.y + eyeOffsetY);
            ctx.stroke();
        } else {
            const eyeRadius = displayRadiusY * 0.15;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(jumper.x - 7, jumper.y + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(jumper.x + 7, jumper.y + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            const pupilRadius = eyeRadius * 0.5;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(jumper.x - 7, jumper.y + eyeOffsetY, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(jumper.x + 7, jumper.y + eyeOffsetY, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        const beakY = jumper.y - displayRadiusY * 0.1;
        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        if (!jumper.onGround && !jumper.isCharging) {
            ctx.moveTo(jumper.x, beakY);
            ctx.lineTo(jumper.x - 5, beakY + 5);
            ctx.lineTo(jumper.x + 5, beakY + 5);
        } else {
            ctx.moveTo(jumper.x, beakY);
            ctx.lineTo(jumper.x - 5, beakY + 2);
            ctx.lineTo(jumper.x + 5, beakY + 2);
        }
        ctx.closePath();
        ctx.fill();
    }
    
    function drawGoal() {
        ctx.fillStyle = levelState.hasKey ? '#8B4513' : '#654321'; 
        drawRoundRect(ctx, goal.x, goal.y, goal.width, goal.height, 5);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(goal.x + goal.width - 10 + 3, goal.y + goal.height / 2 + 3, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(goal.x + goal.width - 10, goal.y + goal.height / 2, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawKey() {
        if (levelState.hasKey) return;
        const key = levelState.keyPos;
        const shadowOffset = 3;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(key.x + shadowOffset, key.y - 10 + shadowOffset, 10, 0, Math.PI * 2); 
        ctx.fillRect(key.x - 2.5 + shadowOffset, key.y + shadowOffset, 5, 20); 
        ctx.fillRect(key.x - 2.5 + shadowOffset, key.y + 15 + shadowOffset, 10, 5); 
        ctx.fill();
        
        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.arc(key.x, key.y - 10, 10, 0, Math.PI * 2);
        ctx.fillRect(key.x - 2.5, key.y, 5, 20);
        ctx.fillRect(key.x - 2.5, key.y + 15, 10, 5);
        ctx.fill();
    }

    function drawLife() {
        if (levelState.lifeCollected) return;
        const life = levelState.lifePos;
        const x = life.x;
        const y = life.y;
        const width = 20;
        const height = 20;
        const shadowOffset = 3;

        const drawHeart = (offsetX, offsetY) => {
            const w = width;
            const h = height;
            const top = y - h / 2 + offsetY;
            const left = x - w / 2 + offsetX;

            ctx.beginPath();
            ctx.moveTo(left + w / 2, top + h / 4);
            ctx.quadraticCurveTo(left, top, left, top + h / 2);
            ctx.quadraticCurveTo(left, top + h, left + w / 2, top + h);
            ctx.quadraticCurveTo(left + w, top + h, left + w, top + h / 2);
            ctx.quadraticCurveTo(left + w, top, left + w / 2, top + h / 4);
            ctx.closePath();
            ctx.fill();
        };

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        drawHeart(shadowOffset, shadowOffset);

        ctx.fillStyle = '#2ecc71';
        drawHeart(0, 0);
    }
    
    function drawSeagulls() {
        seagulls.forEach(seagull => {
            const drawWing = (offsetX, offsetY) => {
                ctx.beginPath();
                ctx.moveTo(seagull.x + offsetX, seagull.y + offsetY);
                ctx.quadraticCurveTo(seagull.x + seagull.width / 4 + offsetX, seagull.y - seagull.height + offsetY, seagull.x + seagull.width / 2 + offsetX, seagull.y + offsetY);
                ctx.moveTo(seagull.x + seagull.width / 2 + offsetX, seagull.y + offsetY);
                ctx.quadraticCurveTo(seagull.x + (seagull.width * 3 / 4) + offsetX, seagull.y - seagull.height + offsetY, seagull.x + seagull.width + offsetX, seagull.y + offsetY);
                ctx.stroke();
            };
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 4;
            drawWing(3, 3);
            
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            drawWing(0, 0);
        });
    }

    function drawSpikes() {
        spikes.forEach(spike => {
            let spikeY = (spike.from === 'ceiling') ? 0 : (spike.y || 0);
            if(spike.platformId !== undefined){
                const p = platforms[spike.platformId];
                if(p) spikeY = p.y - spikeHeight;
            }

            const shadowOffset = 3;
            
            const drawSpikeShape = (offsetX, offsetY) => {
                ctx.beginPath();
                if (spike.dir === 'up') {
                    ctx.moveTo(spike.x + offsetX, spikeY + spike.height + offsetY);
                    ctx.lineTo(spike.x + spike.width / 2 + offsetX, spikeY + offsetY);
                    ctx.lineTo(spike.x + spike.width + offsetX, spikeY + spike.height + offsetY);
                } else {
                    ctx.moveTo(spike.x + offsetX, spikeY + offsetY);
                    ctx.lineTo(spike.x + spike.width / 2 + offsetX, spikeY + spike.height + offsetY);
                    ctx.lineTo(spike.x + spike.width + offsetX, spikeY + offsetY);
                }
                ctx.closePath();
                ctx.fill();
            };

            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            drawSpikeShape(shadowOffset, shadowOffset);
            
            ctx.fillStyle = '#c0c0c0';
            drawSpikeShape(0, 0);
        });
    }

    function drawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life--;
            p.opacity -= (p.fadeRate || 0.015);
            p.x += p.speedX;
            p.y += p.speedY;
            
            if (p.life <= 0 || p.opacity <= 0) {
                particles.splice(i, 1);
            } else {
                ctx.beginPath();
                ctx.fillStyle = `rgba(224, 224, 224, ${p.opacity})`;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawUI() {
        ctx.fillStyle = '#e0e0e0';
        ctx.font = '24px "Press Start 2P"';
        ctx.textAlign = 'left';
        
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        ctx.fillText(`Vidas: ${jumper.lives}`, 20, 40);
        ctx.textAlign = 'right';
        ctx.fillText(`Nível: ${level}`, canvas.width - 20, 40);

        ctx.shadowColor = 'transparent';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        const keyIconX = canvas.width / 2 - 15;
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(keyIconX, 25, 8, 0, Math.PI * 2);
        ctx.moveTo(keyIconX, 33);
        ctx.lineTo(keyIconX, 45);
        ctx.moveTo(keyIconX, 42);
        ctx.lineTo(keyIconX + 5, 42);
        if (levelState.hasKey) {
            ctx.fillStyle = '#ffcc00';
            ctx.fill();
            ctx.stroke();
        } else {
            ctx.stroke();
        }

        if (jumper.isCharging) {
            const barWidth = 80;
            const barHeight = 12;
            const barX = jumper.x - barWidth / 2;
            const barY = jumper.y - jumper.radius - 35;
            const chargeWidth = (jumper.chargePower / maxChargePower) * barWidth;
            const shadowOffset = 2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(barX + shadowOffset, barY + shadowOffset, barWidth, barHeight);

            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            if (chargeWidth > 0) {
                const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                gradient.addColorStop(0, '#2ecc71');
                gradient.addColorStop(0.5, '#f1c40f');
                gradient.addColorStop(1, '#e74c3c');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(barX, barY, chargeWidth, barHeight);
            }
            
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
        
        // Crédito do Desenvolvedor
        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.textAlign = 'right';
        ctx.fillText('Powered by ~JoaoGabriel~', canvas.width - 10, canvas.height - 10);
    }
    
    function drawEndScreen(message, color) {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;
        ctx.font = '50px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 30);
        ctx.fillStyle = '#e0e0e0';
        ctx.font = '20px "Press Start 2P"';
        ctx.fillText('Pressione Enter para reiniciar', canvas.width / 2, canvas.height / 2 + 30);
    }
    
    function drawTouchControls() {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 3;

        // Botão Esquerdo
        const left = touchControls.left;
        ctx.beginPath();
        ctx.arc(left.x + left.width / 2, left.y + left.height / 2, left.width / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(left.x + 65, left.y + 30);
        ctx.lineTo(left.x + 35, left.y + 50);
        ctx.lineTo(left.x + 65, left.y + 70);
        ctx.stroke();

        // Botão Direito
        const right = touchControls.right;
        ctx.beginPath();
        ctx.arc(right.x + right.width / 2, right.y + right.height / 2, right.width / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(right.x + 35, right.y + 30);
        ctx.lineTo(right.x + 65, right.y + 50);
        ctx.lineTo(right.x + 35, right.y + 70);
        ctx.stroke();

        // Botão de Pulo
        const jump = touchControls.jump;
        ctx.beginPath();
        ctx.arc(jump.x + jump.width / 2, jump.y + jump.height / 2, jump.width / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.font = '20px "Press Start 2P"';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Pular', jump.x + jump.width / 2, jump.y + jump.height / 2);
        ctx.textBaseline = 'alphabetic';
    }
    
    // --- LÓGICA DO JOGO ---

    function update() {
        if (gameOver || gameWon) return;

        if (keys.space && jumper.onGround) jumper.isCharging = true;
        
        if (keys.right) jumper.dx = horizontalSpeed;
        else if (keys.left) jumper.dx = -horizontalSpeed;
        else jumper.dx = 0;
        
        let wasOnGround = jumper.onGround;

        // Física Vertical: Aplicar gravidade sempre.
        jumper.dy += gravity;
        
        // Mover jogador
        jumper.y += jumper.dy;
        jumper.x += jumper.dx;
        
        jumper.onGround = false; // Assumir que está no ar até que a colisão prove o contrário.

        clouds.forEach(cloud => {
            cloud.x += cloud.speed;
            if (cloud.x > canvas.width + cloud.radius * 2) cloud.x = -cloud.radius * 2;
        });
        
        spikes.forEach(spike => {
            if (spike.speedX) {
                spike.x += spike.speedX;
                if ((spike.speedX > 0 && spike.x > spike.bounds.right) || (spike.speedX < 0 && spike.x < spike.bounds.left)) {
                    spike.speedX *= -1;
                }
            }
        });

        platforms.forEach(p => {
            const speedX = p.speedX || 0;
            const speedY = p.speedY || 0;
            if (speedX !== 0 && p.bounds) {
                p.x += speedX;
                if ((speedX > 0 && p.x + p.width > p.bounds.right) || (speedX < 0 && p.x < p.bounds.left)) p.speedX *= -1;
            }
            if (speedY !== 0 && p.bounds) {
                p.y += speedY;
                 if ((speedY > 0 && p.y + p.height > p.bounds.bottom) || (speedY < 0 && p.y < p.bounds.top)) p.speedY *= -1;
            }

            // Lógica de colisão com plataformas
            if (jumper.x + jumper.radius > p.x && jumper.x - jumper.radius < p.x + p.width) {
                if (jumper.dy >= 0 && (jumper.y - jumper.dy + jumper.radius) <= p.y) {
                     if (jumper.y + jumper.radius >= p.y) {
                        jumper.onGround = true;
                        jumper.y = p.y - jumper.radius;

                        if (!wasOnGround) {
                             const fallSpeed = jumper.dy;
                             if (fallSpeed > gravity * 2) { 
                                jumper.squashFactor = 1.3;
                             }
                        }

                        if (!jumper.isCharging && jumper.dx === 0) {
                             const idleBounceForce = -3.5;
                             jumper.dy = idleBounceForce;
                        } else {
                            jumper.dy = 0;
                        }
                        
                        jumper.x += speedX;
                    }
                } 
                else if (jumper.dy < 0 && jumper.y - jumper.radius < p.y + p.height && jumper.y + jumper.radius > p.y) {
                     jumper.y = p.y + p.height + jumper.radius;
                     jumper.dy *= -0.5;
                }
            }
        });
        
        if (jumper.isCharging) {
            jumper.squashFactor = 0.6;
        } else {
             if (jumper.squashFactor > 1 && !jumper.onGround) {
                 jumper.squashFactor -= 0.05;
             } else if (jumper.squashFactor < 1) {
                 jumper.squashFactor += 0.05;
             }
             if (!jumper.onGround) {
                jumper.squashFactor = 0.9;
             }
        }
        
        if (jumper.onGround && Math.abs(jumper.dx) > 0 && Math.random() > 0.6) {
            particles.push({
                x: jumper.x,
                y: jumper.y + jumper.radius,
                size: Math.random() * 4 + 2,
                life: 30,
                opacity: 0.4,
                speedX: -jumper.dx * (Math.random() * 0.1),
                speedY: -(Math.random() * 0.5 + 0.2),
                fadeRate: 0.015
            });
        }
        
        seagulls.forEach(seagull => {
            seagull.x += seagull.speed;
            if (seagull.speed < 0 && seagull.x + seagull.width < 0) {
                seagull.x = canvas.width;
            } else if (seagull.speed > 0 && seagull.x > canvas.width) {
                seagull.x = -seagull.width;
            }
            const dist = Math.hypot(jumper.x - (seagull.x + seagull.width / 2), jumper.y - seagull.y);
            if (dist < jumper.radius + seagull.height / 2) {
                handleHit();
            }
        });


        if (jumper.x - jumper.radius > canvas.width) jumper.x = -jumper.radius;
        else if (jumper.x + jumper.radius < 0) jumper.x = canvas.width + jumper.radius;
        if (jumper.y - jumper.radius > canvas.height) handleHit();
        if (jumper.y - jumper.radius < 0 && !jumper.onGround) {
            jumper.y = jumper.radius;
            jumper.dy *= -bounceFactor;
        }

        if (jumper.isCharging && jumper.onGround) {
            if (jumper.chargePower < maxChargePower) {
                jumper.chargePower += 0.5;
            }
        }
        
        if (!levelState.hasKey) {
            const dist = Math.hypot(jumper.x - levelState.keyPos.x, jumper.y - levelState.keyPos.y);
            if (dist < jumper.radius + 15) levelState.hasKey = true;
        }
        if (!levelState.lifeCollected) {
            const dist = Math.hypot(jumper.x - levelState.lifePos.x, jumper.y - levelState.lifePos.y);
            if (dist < jumper.radius + 15) {
                levelState.lifeCollected = true;
                jumper.lives++;
            }
        }
        
        spikes.forEach(spike => {
            const collisionY = (spike.from === 'ceiling') ? 0 : (spike.y || 0);
            if (jumper.x + jumper.radius > spike.x && jumper.x - jumper.radius < spike.x + spike.width &&
                jumper.y + jumper.radius > collisionY && jumper.y - jumper.radius < collisionY + spike.height) {
                handleHit();
            }
        });
        
        if (levelState.hasKey && jumper.x + jumper.radius > goal.x && jumper.x - jumper.radius < goal.x + goal.width &&
            jumper.y + jumper.radius > goal.y && jumper.y - jumper.radius < goal.y + goal.height) {
            level++;
            loadLevel(level);
        }
    }

    function handleHit() {
        jumper.lives--;
        if (jumper.lives <= 0) gameOver = true;
        else loadLevel(level);
    }

    function resetGame() {
        gameOver = false;
        gameWon = false;
        jumper.lives = 3;
        level = 1;
        sunY = 150;
        loadLevel(level);
    }
    
    function gameLoop() {
        requestAnimationFrame(gameLoop);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawBackground();
        drawPlatforms();
        drawSpikes();
        drawSeagulls();
        drawGoal();
        drawKey();
        drawLife();
        drawParticles();
        drawJumper();
        
        if (!gameOver && !gameWon) {
            update();
            drawUI();
            drawTouchControls();
        } else if (gameOver) {
            drawEndScreen('FIM DE JOGO', '#e94560');
        } else if (gameWon) {
            drawEndScreen('VOCÊ VENCEU!', '#2de2e6');
        }
    }

    // --- EVENTOS DE CONTROLE ---
    
    function executeJump() {
        if (!jumper.isCharging) return;

        // Fumaça Ilustrativa ao Soltar o Pulo
        const particleCount = 10 + Math.floor(jumper.chargePower * 0.8);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.PI + Math.random() * Math.PI; // Semicírculo para cima
            const speed = 1 + (Math.random() * jumper.chargePower / 10);
            particles.push({
                x: jumper.x,
                y: jumper.y + jumper.radius, // Origem nos pés
                size: Math.random() * 5 + 3,
                life: 50 + Math.random() * 20,
                opacity: 0.6,
                speedX: Math.cos(angle) * speed,
                speedY: Math.sin(angle) * speed,
                fadeRate: 0.02
            });
        }

        jumper.dy = minJumpForce - jumper.chargePower;
        jumper.onGround = false;
        jumper.isCharging = false;
        jumper.chargePower = 0;
        jumper.squashFactor = 0.8;
    }
    
    function keyDownHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') keys.right = true;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') keys.left = true;
        else if (e.code === 'Space') keys.space = true;
        else if (e.key === 'Enter' && (gameOver || gameWon)) resetGame();
    }

    function keyUpHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') keys.right = false;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') keys.left = false;
        else if (e.code === 'Space') {
            keys.space = false;
            if(jumper.isCharging) executeJump();
            jumper.isCharging = false;
        }
    }

    function handleTouch(e, isStart) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        for (const touch of e.changedTouches) {
            const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const touchY = (touch.clientY - rect.top) * (canvas.height / rect.height);

            const check = (control) => {
                return touchX >= control.x && touchX <= control.x + control.width &&
                       touchY >= control.y && touchY <= control.y + control.height;
            };

            if (isStart) {
                if (check(touchControls.left)) touchMap[touch.identifier] = 'left';
                else if (check(touchControls.right)) touchMap[touch.identifier] = 'right';
                else if (check(touchControls.jump)) touchMap[touch.identifier] = 'jump';
            }

            const action = isStart ? touchMap[touch.identifier] : null;

            keys.left = false;
            keys.right = false;
            if(!isStart && touchMap[touch.identifier] === 'jump') {
                keys.space = false;
                if(jumper.isCharging) executeJump();
                jumper.isCharging = false;
            } else {
                 keys.space = false;
            }


            for(const id in touchMap){
                const control = touchMap[id];
                if(control === 'left') keys.left = true;
                if(control === 'right') keys.right = true;
                if(control === 'jump') keys.space = true;
            }

            if (!isStart) {
                delete touchMap[touch.identifier];
            }
        }
    }


    function resizeCanvas() {
        const aspectRatio = 800 / 600;
        let newWidth = window.innerWidth;
        let newHeight = window.innerHeight;
        const windowAspectRatio = newWidth / newHeight;
        
        const container = document.getElementById('game-container');
        const containerHeight = container.clientHeight;
        const containerWidth = container.clientWidth;

        if (windowAspectRatio > aspectRatio) {
            newHeight = containerHeight * 0.95;
            newWidth = newHeight * aspectRatio;
        } else {
            newWidth = containerWidth * 0.95;
            newHeight = newWidth / aspectRatio;
        }

        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;
    }

    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('keydown', keyDownHandler);
    document.addEventListener('keyup', keyUpHandler);
    canvas.addEventListener('touchstart', (e) => handleTouch(e, true));
    canvas.addEventListener('touchend', (e) => handleTouch(e, false));
    canvas.addEventListener('touchcancel', (e) => handleTouch(e, false));


    initClouds();
    loadLevel(level);
    resizeCanvas(); // Ajusta o tamanho inicial
    gameLoop();

</script>

</body>
</html>

